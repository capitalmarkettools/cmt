'''
Created on Feb 2, 2010

@author: capitalmarkettools
'''
import QuantLib
from src.bo.instruments import Position
from src.bo.static import Basis
from src.bo import ErrorHandling, Date
from src.bo.Enum import AssetType, Index
from src.bo import MarketDataContainer
from src.bo.decorators import log
from src.models import InterestRateCurve, TCSwap

@log
class SwapPosition(Position.Position):
    def __init__(self, amount = None, secId = '', tcSwap = None):
        '''
        amount is required
        either secId or tcSwap is required
        secid is an autogenerated identifier
        swap000000000, swap000000001....
        '''
        self._tcSwap = None
        Position.Position.__init__(self, 'SwapPosition', amount, secId)
        if tcSwap == None:
            self._tcSwap = TCSwap.objects.get(name=secId)
        else:
            self._tcSwap = tcSwap
        self._qlSwap = None
        self._pricingDate = None
        
    def __str__(self):
        return '<%s,%s,%d>' % (self.__class__, self.secId, self.amount)
    
    def marketData(self, pricingDate, marketId=''):
        irCurve = InterestRateCurve()
        irCurve.ccy = self._tcSwap.ccy
        irCurve.index = Index('LIBOR')
        irCurve.term = 'M'
        irCurve.numTerms = 3
        irCurve.pricingDate = pricingDate
        irCurve.marketId = marketId
        irCurve.load()
        l = []
        l.append(irCurve)
        return l
    
    def loadAndSaveMarketData(self, pricingDate, marketId):
        ''' assumes that 'EOD' marketId exists
        algorithm is to load the EOD curve and save it with marketId
        '''
        eodCurve = InterestRateCurve()
        eodCurve.ccy = self._tcSwap.ccy
        eodCurve.index = Index('LIBOR')
        eodCurve.term = 'M'
        eodCurve.numTerms = 3
        eodCurve.pricingDate = pricingDate
        eodCurve.marketId = 'EOD'
        eodCurve.load()
        irCurve = InterestRateCurve()
        irCurve.ccy = self._tcSwap.ccy
        irCurve.index = Index('LIBOR')
        irCurve.term = 'M'
        irCurve.numTerms = 3
        irCurve.pricingDate = pricingDate
        irCurve.marketId = marketId
        eodRates = eodCurve.getRates()
        for rate in eodRates:
            irCurve.addRate(rate)
        irCurve.save()
        
    def _setupQL(self, pricingDate, marketId=''):
        QuantLib.Settings.instance().evaluationDate = pricingDate.ql()
#        print 'in setupql'
        self._pricingDate = pricingDate
        # Get market data curve based on Ccy/Index
        curve = InterestRateCurve()
        curve.pricingDate = pricingDate
        curve.ccy = self._tcSwap.ccy
        curve.index = Index('LIBOR')
        curve.term = 'M'
        curve.numTerms = self._tcSwap.floatingIndexNumTerms
        curve.marketId = marketId
        if self.marketDataContainer == None:
            raise ErrorHandling.MarketDataMissing('marketDataContainer is None')
        newCurve = self.marketDataContainer.find(curve)
        if newCurve == None:
            raise ErrorHandling.MarketDataMissing('Cannot find market data %s' % curve)
        depositCurve = newCurve.buildZeroCurve()
        discountTermStructure = QuantLib.RelinkableYieldTermStructureHandle()
        discountTermStructure.linkTo(depositCurve)

        swapEngine = QuantLib.DiscountingSwapEngine(discountTermStructure)

        #TODO fix the discounting curve to make if projected fwd curve
        index = QuantLib.Euribor6M(discountTermStructure)

        #fixingDate = Date.Date(month=9,day=10,year=2012)
        #index.addFixing(fixingDate.ql(),0.02)
        
        #tcSwap dates are python dates
        fixedSchedule = QuantLib.Schedule(Date.createQLDateFromPythonDate(self._tcSwap.startDate),
                                          Date.createQLDateFromPythonDate(self._tcSwap.endDate),
                                          #fixedLegTenor is QuantLib.Period(n,unit)
                                          #Period is an integer (n) and TimePeriod (unit)
                                          #TODO fix payment freq
                                          QuantLib.Period(6,QuantLib.Months),
                                          self._tcSwap.fixedPaymentCalendar.ql(),
                                          self._tcSwap.fixedPaymentRollRule.ql(),
                                          self._tcSwap.fixedPaymentRollRule.ql(),
                                          QuantLib.DateGeneration.Forward, 
                                          False)
        
        floatingSchedule = QuantLib.Schedule(Date.createQLDateFromPythonDate(self._tcSwap.startDate),
                                          Date.createQLDateFromPythonDate(self._tcSwap.endDate),
                                          #fixedLegTenor is QuantLib.Period(n,unit)
                                          #Period is an integer (n) and TimePeriod (unit)
                                          #TODO fix payment freq
                                          QuantLib.Period(3,QuantLib.Months),
                                          self._tcSwap.floatingPaymentCalendar.ql(),
                                          self._tcSwap.floatingPaymentRollRule.ql(),
                                          self._tcSwap.floatingPaymentRollRule.ql(),
                                          QuantLib.DateGeneration.Forward, 
                                          False) 
    
    #TODO: FIx to decide if it's payer or receiver fixed
        self._qlSwap = QuantLib.VanillaSwap(QuantLib.VanillaSwap.Payer, 
                                            self.amount,
                                            fixedSchedule, 
                                            self._tcSwap.fixedCoupon, 
                                            self._tcSwap.fixedBasis.ql(),
                                            floatingSchedule, 
                                            #TODO fix index
                                            index,
                                            self._tcSwap.floatingSpread,
                                            self._tcSwap.floatingBasis.ql())
        
        self._qlSwap.setPricingEngine(swapEngine)
        self.upToDate = True
    
    def NPV(self, pricingDate, marketId=''):
#       print 'in npv'
        if self._qlSwap == None or self._pricingDate <> pricingDate or self.upToDate == False:
#           print 'calling setupql'
            self._setupQL(pricingDate, marketId)
#        print str(self)
        return self._qlSwap.NPV()

    def fairSpread(self, pricingDate, marketId=''):
        if self._qlSwap == None or self._pricingDate <> pricingDate or self.upToDate == False:
            self._setupQL(pricingDate, marketId)
        return self._qlSwap.fairSpread()
    
    def fairRate(self, pricingDate, marketId=''):
        if self._qlSwap == None or self._pricingDate <> pricingDate or self.upToDate == False:
            self._setupQL(pricingDate, marketId)
        return self._qlSwap.fairRate()
    
    def fixedLegBPS(self, pricingDate, marketId=''):
        if self._qlSwap == None or self._pricingDate <> pricingDate or self.upToDate == False:
            self._setupQL(pricingDate, marketId)
        return self._qlSwap.fixedLegBPS()

    def floatingLegBPS(self, pricingDate, marketId=''):
        if self._qlSwap == None or self._pricingDate <> pricingDate or self.upToDate == False:
            self._setupQL(pricingDate, marketId)
        return self._qlSwap.floatingLegBPS()
    
    def getAssetType(self):
        return AssetType('IRSWAP')
    
def main():
    pos = SwapPosition(100, 'TEST1')
    pricingDate = Date.Date(month=9, day=12, year=2011)
    marketId = 'TEST1'
    QuantLib.Settings.instance().evaluationDate = pricingDate.ql()
    marketDataContainer = MarketDataContainer.MarketDataContainer()
    marketDataContainer.add(pos.marketData(pricingDate, marketId))
    pos.setMarketDataContainer(marketDataContainer)
    print "Fair Price: " + str(pos.NPV(pricingDate, marketId))
    print "Yield: " + str(pos.PriceToYield(104.3562, pricingDate, marketId)*100) + "%"
    print "Yield to Price: " + str(pos.YieldToPrice(0.03, pricingDate, marketId))
    
if __name__ == "__main__":
    main()